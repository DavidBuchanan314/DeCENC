"""
Parsing ISOBMFF sucks.

All the existing parsers suck.*

This one sucks too, but the suck has been rearranged so that it works for my needs.

(*I say this with love, the many existing codebases were invaluable for this research)

pymp4 is particularly good. The use of Construct means you only need to describe each box once, and you get an encoder and decoder for free.
However, that approach wasn't flexible enough for my needs.


Some things this needs to be able to do:

- Parse out pssh, senc, and other CENC metadata boxes from arbitrary mp4 files
- Perform the necessary wrangling to add CENC metadata to an existing (but bare-bones, generated by ffmpeg) mp4 file
  - this includes re-inserting the pssh boxes from an original file
  - and generating senc atoms for our new file

Some things this doesn't need to be able to do:

- Everything that isn't those things

"""

from abc import ABC, abstractclassmethod, abstractmethod
from typing import List, BinaryIO, Dict, Tuple, Self, Optional, Iterable
from enum import IntFlag
import io
from lib.util import indent, read_exact, GoodBytesIO


class Box(ABC):
	boxtype: bytes # length 4 or 16
	_registry: Dict[bytes, "Box"] = {}

	def __init__(self) -> None:
		raise Exception("Box cannot be instantiated directly. Maybe you want an OpaqueBox?")
	
	@classmethod # TODO: make class method, check if return type is subclass
	def parse(cls, stream: BinaryIO, ctx: dict) -> "Box":
		start_offset = stream.tell()
		size = int.from_bytes(read_exact(stream, 4), "big")
		boxtype = read_exact(stream, 4)
		if size == 1:
			size = int.from_bytes(read_exact(stream, 8), "big")
			assert(size > 16)
		
		if boxtype == b"uuid":
			boxtype = read_exact(stream, 16)


		body_offset = stream.tell()
		if size == 0: # read until EOF
			body = stream.read()
		else:
			length_remaining = size - (stream.tell() - start_offset)
			body = read_exact(stream, length_remaining)

		specialized_type = Box._registry.get(boxtype)
		if specialized_type and cls is not OpaqueBox: # Don't try to specialize if someone called OpaqueBox.parse()
			body_stream = GoodBytesIO(body, body_offset)
			#print("parsing", specialized_type.boxtype)
			box = specialized_type._from_body(body_stream, ctx)
			assert(body_stream.is_eof())
			if not issubclass(specialized_type, cls):
				raise TypeError(f"You wanted to parse a {cls.__name__}, but a {specialized_type.__name__} came out.")
		else:
			# If cls is not Box or Opaquebox, raise Exception (Should only happen if the box was not registered)
			if not issubclass(OpaqueBox, cls):
				raise Exception(f"You wanted to parse a {cls.__name__}, but an OpaqueBox({boxtype}, ...) came out. Did you forget to register your box class with @Box.register?")
			
			box = OpaqueBox(boxtype, body)
		
		ctx["box_offsets"] = ctx.get("box_offsets", {}) | {box: start_offset}

		return box

	def write_into(self, stream: BinaryIO, ctx: dict):
		headers_len = 8 # XXX: this is only currect for 32-bit length boxes, with no uuid
		body_stream = GoodBytesIO(base_offset=stream.tell()+headers_len)
		self._into_body(body_stream, ctx)
		body = body_stream.getvalue()

		has_uuid = len(self.boxtype) != 4
		box_size =  8 + (16 * has_uuid) + len(body)
		is_big = box_size >= 2**32
		stream.write((1 if is_big else box_size).to_bytes(4, "big"))
		stream.write(b"uuid" if has_uuid else self.boxtype)
		if is_big:
			stream.write((box_size + 8).to_bytes("big"))
		if has_uuid:
			assert(len(self.boxtype) == 16)
			stream.write(self.boxtype)
		stream.write(body)
	
	@staticmethod # helper for fullbox parsing
	def _read_fullbox(stream: GoodBytesIO) -> Tuple[int, int]:
		version = stream.readBEU08()
		flags = stream.readBEU24()
		return version, flags
	
	@staticmethod # helper for fullbox serialization
	def _write_fullbox(stream: GoodBytesIO, version: int, flags: int) -> None:
		stream.writeBEU08(version)
		stream.writeBEU24(flags)

	@abstractclassmethod
	def _from_body(cls, body: GoodBytesIO, ctx: dict) -> Self:
		"""
		This is where subclassses should implement their own parsing logic
		"""
		pass

	@abstractmethod
	def _into_body(self, body: GoodBytesIO, ctx: dict) -> None:
		"""
		This is where subclassses should implement their own serialization logic
		"""
		pass

	@classmethod # decorator
	def register(cls, boxclass: "Box") -> "Box":
		if cls is not Box:
			raise Exception("You can only register subclasses against the Box base class")
		assert(len(boxclass.boxtype) in [4, 16])
		Box._registry[boxclass.boxtype] = boxclass
		return boxclass
	
	def bake_offsets(self) -> Dict["Box", int]:
		buf = io.BytesIO()
		self.write_into(buf, {})
		buf.seek(0) # rewind
		bakectx = {}
		bakedbox = Box.parse(buf, bakectx)

		# our output dict needs to be indexable by the original box indices
		orig_offsets = {}
		for orig, baked in zip(self.iter_all(), bakedbox.iter_all()):
			orig_offsets[orig] = bakectx["box_offsets"][baked]

		return orig_offsets

	def __repr__(self) -> str:
		args = []
		for k, v in self.__dict__.items():
			if type(v) is bytes and len(v) > 0x100:
				v = f"{v[:0x100]}..."
			elif isinstance(v, IntFlag):
				v = repr(v)
			args.append(f"{k}={v}")

		if len(args) < 2: # TODO: tweak cutover logic? based it on combined args len?
			return f"{self.__class__.__name__}({', '.join(args)})"
		
		return f"{self.__class__.__name__}(\n{',\n'.join(map(indent, args))}\n)"

	def __bytes__(self) -> bytes:
		buf = io.BytesIO()
		self.write_into(buf, {})
		return buf.getvalue()

class OpaqueBox(Box):
	def __init__(self, boxtype: bytes, body: bytes) -> None:
		assert(len(boxtype) in [4, 16])
		self.boxtype = boxtype
		self.body = body
	
	@classmethod
	def _from_body(cls, body: GoodBytesIO, ctx: dict) -> Self:
		raise Exception("OpaqueBoxes cannot be parsed from body, since the type must be known. Instantiate one directly.")

	def _into_body(self, body: GoodBytesIO, ctx: dict) -> None:
		body.write(self.body)


class ContainerBox(Box):
	children: List[Box]

	def __init__(self, children: List[Box]) -> None:
		self.children = children

	@classmethod
	def _from_body(cls, body: GoodBytesIO, ctx: dict) -> Self:
		children = []
		while not body.is_eof():
			ctx["container_offset"] = body.tell() # useful for saio
			children.append(Box.parse(body, ctx))
		return cls(children)
	
	def _into_body(self, body: GoodBytesIO, ctx: dict) -> None:
		for child in self.children:
			ctx["container_offset"] = body.tell() # useful for saio
			child.write_into(body, ctx)
	
	def __repr__(self):
		if len(self.children) < 2: # TODO: tweak cutover
			return f"{self.__class__.__name__}([{', '.join(map(repr, self.children))}])"
		return f"{self.__class__.__name__}([\n{',\n'.join(map(indent,map(repr, self.children)))}\n])"


	# some convenience methods for ergonomic box manipulation

	def __iter__(self):
		return self.children.__iter__()
	
	# find first child of type (arg should be type or bytes)
	def __truediv__(self, other) -> Box:
		if issubclass(other, Box):
			other = other.boxtype
		for child in self.children:
			if child.boxtype == other:
				return child
		raise ZeroDivisionError(f"No matching box found for type {other}") # lol
	
	# find all of matching types (arg should be type or bytes)
	def __getitem__(self, item) -> List[Box]:
		if type(item) is not bytes and issubclass(item, Box):
			item = item.boxtype
		return [child for child in self.children if child.boxtype == item]

	def iter_all(self) -> Iterable[Box]:
		yield from self
		for child in self:
			if isinstance(child, ContainerBox):
				yield from child.iter_all()

	def findall(self, needle: Box | bytes) -> List[Box]:
		return sum(
			map(
				lambda c: c.findall(needle),
				filter(lambda c: isinstance(c, ContainerBox), self)
			),
			self[needle]
		)


@Box.register
class Ftyp(Box):
	"""
	4.3 File Type Box
	"""
	boxtype = b"ftyp"

	def __init__(self, major_brand: bytes, minor_version: int, compatible_brands: List[bytes]) -> None:
		self.major_brand = major_brand
		self.minor_version = minor_version
		self.compatible_brands = compatible_brands
	
	@classmethod
	def _from_body(cls, body: GoodBytesIO, ctx: dict) -> Self:
		major_brand = body.read_exact(4)
		minor_version = body.readBEU32()
		compatible_brands = []
		while not body.is_eof():
			compatible_brands.append(body.read_exact(4))
		return cls(major_brand, minor_version, compatible_brands)
	
	def _into_body(self, body: GoodBytesIO, ctx: dict) -> None:
		body.write(self.major_brand)
		body.writeBEU32(self.minor_version)
		for brand in self.compatible_brands:
			body.write(brand)

@Box.register
class Moov(ContainerBox):
	"""
	8.2.1 Movie Box
	"""
	boxtype = b"moov"

@Box.register
class Mvhd(Box):
	"""
	8.2.2 Movie Header Box
	"""
	boxtype = b"mvhd"
	
	def __init__(self,
		creation_time: int,
		modification_time: int,
		timescale: int,
		duration: int,
		next_track_ID: int,
		rate: Tuple[int, int]=(1, 0),
		volume: Tuple[int, int]=(1, 0),
		matrix: List[int]=[0x00010000, 0, 0, 0, 0x00010000, 0, 0, 0, 0x40000000]
	) -> None:
		self.creation_time = creation_time
		self.modification_time = modification_time
		self.timescale = timescale
		self.duration = duration
		self.next_track_ID = next_track_ID
		self.rate = rate
		self.volume = volume
		self.matrix = matrix

	@classmethod
	def _from_body(cls, body: GoodBytesIO, ctx: dict) -> Self:
		version, flags = cls._read_fullbox(body)
		assert(flags == 0)
		if version == 0:
			creation_time = body.readBEU32()
			modification_time = body.readBEU32()
			timescale = body.readBEU32()
			duration = body.readBEU32()
		elif version == 1:
			creation_time = body.readBEU64()
			modification_time = body.readBEU64()
			timescale = body.readBEU32()
			duration = body.readBEU64()
		else:
			raise ValueError(f"Unrecognised version: {version}")
		rate = body.readFP1616()
		volume = body.readFP0808()
		assert(body.readBEU16() == 0) # reserved
		assert(body.readBEU32() == 0) # reserved
		assert(body.readBEU32() == 0) # reserved
		matrix = [body.readBEU32() for _ in range(9)]
		for _ in range(6):
			assert(body.readBEU32() == 0) # pre_defined
		next_track_ID = body.readBEU32()

		return cls(
			creation_time=creation_time,
			modification_time=modification_time,
			timescale=timescale,
			duration=duration,
			next_track_ID = next_track_ID,
			rate=rate,
			volume=volume,
			matrix=matrix
		)
	
	def _into_body(self, body: GoodBytesIO, ctx: dict) -> None:
		version = 0 if all(x < 2**32 for x in [self.creation_time, self.modification_time, self.duration]) else 1
		self._write_fullbox(body, version=version, flags=0)
		if version == 0:
			body.writeBEU32(self.creation_time)
			body.writeBEU32(self.modification_time)
			body.writeBEU32(self.timescale)
			body.writeBEU32(self.duration)
		else:
			body.writeBEU64(self.creation_time)
			body.writeBEU64(self.modification_time)
			body.writeBEU32(self.timescale)
			body.writeBEU64(self.duration)
		body.writeFP1616(self.rate)
		body.writeFP0808(self.volume)
		body.writeBEU16(0) # reserved
		body.writeBEU32(0) # reserved
		body.writeBEU32(0) # reserved
		for elem in self.matrix:
			body.writeBEU32(elem)
		for _ in range(6):
			body.writeBEU32(0) # pre_defined
		body.writeBEU32(self.next_track_ID)

@Box.register
class Trak(ContainerBox):
	"""
	8.3.1 Track Box
	"""
	boxtype = b"trak"


@Box.register
class Tkhd(Box):
	"""
	8.3.2 Track Header Box
	"""
	boxtype = b"tkhd"

	class Flags(IntFlag):
		track_enabled = 0x000001
		track_in_movie = 0x000002
		track_in_preview = 0x000004
		track_size_is_aspect_ratio = 0x000008
	
	def __init__(self,
		flags: Flags,
		creation_time: int,
		modification_time: int,
		track_ID: int,
		duration: int,
		width: Tuple[int, int],
		height: Tuple[int, int],
		layer: int=0,
		alternate_group: int=0,
		volume: int=0x0100, # XXX: if track_is_audio 0x0100 else 0
		matrix: List[int]=[0x00010000, 0, 0, 0, 0x00010000, 0, 0, 0, 0x40000000]
	) -> None:
		self.flags = flags
		self.creation_time = creation_time
		self.modification_time = modification_time
		self.track_ID = track_ID
		self.duration = duration
		self.width = width
		self.height = height
		self.layer = layer
		self.alternate_group = alternate_group
		self.volume = volume
		self.matrix = matrix

	@classmethod
	def _from_body(cls, body: GoodBytesIO, ctx: dict) -> Self:
		version, flags = cls._read_fullbox(body)
		flags = cls.Flags(flags)
		if version == 0:
			creation_time = body.readBEU32()
			modification_time = body.readBEU32()
			track_ID = body.readBEU32()
			assert(body.readBEU32() == 0) # reserved
			duration = body.readBEU32()
		elif version == 1:
			creation_time = body.readBEU64()
			modification_time = body.readBEU64()
			track_ID = body.readBEU32()
			assert(body.readBEU32() == 0) # reserved
			duration = body.readBEU64()
		else:
			raise ValueError(f"Unrecognised version: {version}")
		assert(body.readBEU32() == 0) # reserved
		assert(body.readBEU32() == 0) # reserved
		layer = body.readBEU16()
		alternate_group = body.readBEU16()
		volume = body.readBEU16()
		assert(body.readBEU16() == 0) # reserved
		matrix = [body.readBEU32() for _ in range(9)]
		width = body.readFP1616()
		height = body.readFP1616()

		return cls(
			flags=flags,
			creation_time=creation_time,
			modification_time=modification_time,
			track_ID=track_ID,
			duration=duration,
			width=width,
			height=height,
			layer=layer,
			alternate_group=alternate_group,
			volume=volume,
			matrix=matrix
		)
	
	def _into_body(self, body: GoodBytesIO, ctx: dict) -> None:
		version = version = 0 if all(x < 2**32 for x in [self.creation_time, self.modification_time, self.duration]) else 1
		self._write_fullbox(body, version=version, flags=int(self.flags))
		if version == 0:
			body.writeBEU32(self.creation_time)
			body.writeBEU32(self.modification_time)
			body.writeBEU32(self.track_ID)
			body.writeBEU32(0) # reserved
			body.writeBEU32(self.duration)
		else:
			body.writeBEU64(self.creation_time)
			body.writeBEU64(self.modification_time)
			body.writeBEU32(self.track_ID)
			body.writeBEU32(0) # reserved
			body.writeBEU64(self.duration)
		body.writeBEU32(0) # reserved
		body.writeBEU32(0) # reserved
		body.writeBEU16(self.layer)
		body.writeBEU16(self.alternate_group)
		body.writeBEU16(self.volume)
		body.writeBEU16(0) # reserved
		for elem in self.matrix:
			body.writeBEU32(elem)
		body.writeFP1616(self.width)
		body.writeFP1616(self.height)


@Box.register
class Mdia(ContainerBox):
	"""
	8.4.1 Media Box
	"""
	boxtype = b"mdia"


@Box.register
class Hdlr(Box):
	"""
	8.4.3 Handler Reference Box
	"""
	boxtype = b"hdlr"

	def __init__(self, handler_type: bytes, name: str) -> None:
		assert(len(handler_type) == 4)
		self.handler_type = handler_type
		self.name = name

	@classmethod
	def _from_body(cls, body: GoodBytesIO, ctx: dict) -> Self:
		version, flags = cls._read_fullbox(body)
		assert(version == 0)
		assert(flags == 0)
		assert(body.readBEU32() == 0) # pre_defined
		handler_type = body.read_exact(4)
		for _ in range(3):
			assert(body.readBEU32() == 0) # reserved
		name = body.read().rstrip(b"\0").decode() # strip null termination
		return cls(
			handler_type=handler_type,
			name=name
		)
	
	def _into_body(self, body: GoodBytesIO, ctx: dict) -> None:
		self._write_fullbox(body, version=0, flags=0)
		body.writeBEU32(0) # pre_defined
		body.write(self.handler_type)
		for _ in range(3):
			body.writeBEU32(0) # reserved
		body.write(self.name.encode() + b"\0") # null terminate


@Box.register
class Minf(ContainerBox):
	"""
	8.4.4 Media Information Box
	"""
	boxtype = b"minf"


@Box.register
class Dinf(ContainerBox):
	"""
	8.7.1 Data Information Box
	"""
	boxtype = b"dinf"


@Box.register
class Stbl(ContainerBox):
	"""
	8.5.1 Sample Table Box
	"""
	boxtype = b"stbl"


@Box.register
class MP4ASampleEntryBox(ContainerBox): # kinda fake
	boxtype = b"mp4a"

	def __init__(self, blob: bytes, children: List[Box]) -> None:
		self.blob = blob # unholy hack, I'm too lazy to parse this properly
		self.children = children
	
	@classmethod
	def _from_body(cls, body: GoodBytesIO, ctx: dict) -> Self:
		# disgusting
		blob = body.read_exact(28)

		children = []
		while not body.is_eof():
			children.append(Box.parse(body, ctx))

		return cls(
			blob=blob,
			children=children
		)

	def _into_body(self, body: GoodBytesIO, ctx: dict) -> None:
		body.write(self.blob)
		for child in self.children:
			child.write_into(body, ctx)

@Box.register
class EncryptedMP4ASampleEntryBox(MP4ASampleEntryBox): # kinda fake
	boxtype = b"enca"

@Box.register
class AVC1SampleEntryBox(ContainerBox): # kinda fake
	boxtype = b"avc1"

	def __init__(self,
		data_reference_index: int,
		width: int,
		height: int,
		horizresolution: Tuple[int, int],
		vertresolution: Tuple[int, int],
		frame_count: int,
		compressorname: bytes,
		depth: int,
		children: List[Box]
	) -> None:
		self.data_reference_index = data_reference_index
		self.width = width
		self.height = height
		self.horizresolution = horizresolution
		self.vertresolution = vertresolution
		self.frame_count = frame_count
		self.compressorname = compressorname
		self.depth = depth
		self.children = children

	@classmethod
	def _from_body(cls, body: GoodBytesIO, ctx: dict) -> Self:
		# class SampleEntry
		for _ in range(6):
			assert(body.readBEU08() == 0) # reserved
		data_reference_index = body.readBEU16()

		# class VisualSampleEntry
		assert(body.readBEU16() == 0) # pre_defined
		assert(body.readBEU16() == 0) # reserved
		for _ in range(3):
			assert(body.readBEU32() == 0) # pre_defined

		width = body.readBEU16()
		height = body.readBEU16()
		horizresolution = body.readFP1616()
		vertresolution = body.readFP1616()
		assert(body.readBEU32() == 0) # reserved
		frame_count = body.readBEU16()
		compressorname = body.read_exact(32)
		depth = body.readBEU16()
		assert(body.readBEU16() == 0xffff) # pre_defined

		children = []
		while not body.is_eof():
			children.append(Box.parse(body, ctx))

		return cls(
			data_reference_index=data_reference_index,
			width=width,
			height=height,
			horizresolution=horizresolution,
			vertresolution=vertresolution,
			frame_count=frame_count,
			compressorname=compressorname,
			depth=depth,
			children=children
		)

	def _into_body(self, body: GoodBytesIO, ctx: dict) -> None:
		for _ in range(6):
			body.writeBEU08(0) # reserved
		body.writeBEU16(self.data_reference_index)
		body.writeBEU16(0) # pre_defined
		body.writeBEU16(0) # reserved
		for _ in range(3):
			body.writeBEU32(0) # pre_defined
		body.writeBEU16(self.width)
		body.writeBEU16(self.height)
		body.writeFP1616(self.horizresolution)
		body.writeFP1616(self.vertresolution)
		body.writeBEU32(0) # reserved
		body.writeBEU16(self.frame_count)
		body.write(self.compressorname)
		body.writeBEU16(self.depth)
		body.writeBEU16(0xffff) # pre_defined

		for child in self.children:
			child.write_into(body, ctx)



@Box.register
class HEV1SampleEntryBox(ContainerBox): # very fake
	boxtype = b"hev1"

	def __init__(self,
		data_reference_index: int,
		width: int,
		height: int,
		horizresolution: Tuple[int, int],
		vertresolution: Tuple[int, int],
		frame_count: int,
		compressorname: bytes,
		depth: int,
		children: List[Box]
	) -> None:
		self.data_reference_index = data_reference_index
		self.width = width
		self.height = height
		self.horizresolution = horizresolution
		self.vertresolution = vertresolution
		self.frame_count = frame_count
		self.compressorname = compressorname
		self.depth = depth
		self.children = children

	@classmethod
	def _from_body(cls, body: GoodBytesIO, ctx: dict) -> Self:
		# class SampleEntry
		for _ in range(6):
			assert(body.readBEU08() == 0) # reserved
		data_reference_index = body.readBEU16()

		# class VisualSampleEntry
		assert(body.readBEU16() == 0) # pre_defined
		assert(body.readBEU16() == 0) # reserved
		for _ in range(3):
			assert(body.readBEU32() == 0) # pre_defined

		width = body.readBEU16()
		height = body.readBEU16()
		horizresolution = body.readFP1616()
		vertresolution = body.readFP1616()
		assert(body.readBEU32() == 0) # reserved
		frame_count = body.readBEU16()
		compressorname = body.read_exact(32)
		depth = body.readBEU16()
		assert(body.readBEU16() == 0xffff) # pre_defined

		children = []
		while not body.is_eof():
			children.append(Box.parse(body, ctx))

		return cls(
			data_reference_index=data_reference_index,
			width=width,
			height=height,
			horizresolution=horizresolution,
			vertresolution=vertresolution,
			frame_count=frame_count,
			compressorname=compressorname,
			depth=depth,
			children=children
		)

	def _into_body(self, body: GoodBytesIO, ctx: dict) -> None:
		for _ in range(6):
			body.writeBEU08(0) # reserved
		body.writeBEU16(self.data_reference_index)
		body.writeBEU16(0) # pre_defined
		body.writeBEU16(0) # reserved
		for _ in range(3):
			body.writeBEU32(0) # pre_defined
		body.writeBEU16(self.width)
		body.writeBEU16(self.height)
		body.writeFP1616(self.horizresolution)
		body.writeFP1616(self.vertresolution)
		body.writeBEU32(0) # reserved
		body.writeBEU16(self.frame_count)
		body.write(self.compressorname)
		body.writeBEU16(self.depth)
		body.writeBEU16(0xffff) # pre_defined

		for child in self.children:
			child.write_into(body, ctx)



@Box.register
class EncryptedAVC1SampleEntryBox(AVC1SampleEntryBox): # kinda fake
	boxtype = b"encv"

@Box.register
class Stsd(ContainerBox):
	"""
	8.5.2 Sample Description Box

	TODO: understand what the heck is going on in here lol
	"""
	boxtype = b"stsd"

	def __init__(self, children: List[Box]) -> None:
		self.children = children

	@classmethod
	def _from_body(cls, body: GoodBytesIO, ctx: dict) -> Self:
		version, flags = cls._read_fullbox(body)
		assert(version == 0)
		assert(flags == 0)
		entry_count = body.readBEU32()
		children = []
		for _ in range(entry_count):
			box = Box.parse(body, ctx)
			children.append(box)
		return cls(children)
	
	def _into_body(self, body: GoodBytesIO, ctx: dict) -> None:
		self._write_fullbox(body, version=0, flags=0)
		body.writeBEU32(len(self.children))
		for child in self.children:
			child.write_into(body, ctx)


@Box.register
class Moof(ContainerBox):
	"""
	8.8.4 Movie Fragment Box
	"""
	boxtype = b"moof"


@Box.register
class Mfhd(Box):
	"""
	8.8.5 Movie Fragment Header Box
	"""
	boxtype = b"mfhd"

	def __init__(self, sequence_number: int) -> None:
		self.sequence_number = sequence_number
	
	@classmethod
	def _from_body(cls, body: GoodBytesIO, ctx: dict) -> Self:
		version, flags = cls._read_fullbox(body)
		assert(version == 0)
		assert(flags == 0)
		sequence_number = body.readBEU32()
		return cls(sequence_number=sequence_number)
	
	def _into_body(self, body: GoodBytesIO, ctx: dict) -> None:
		self._write_fullbox(body, version=0, flags=0)
		body.writeBEU32(self.sequence_number)


@Box.register
class Traf(ContainerBox):
	"""
	8.8.6 Track Fragment Box
	"""
	boxtype = b"traf"


@Box.register
class Tfhd(Box):
	"""
	8.8.7 Track Fragment Header Box
	"""
	boxtype = b"tfhd"

	class Flags(IntFlag):
		base_data_offset_present = 0x000001
		sample_description_index_present = 0x000002
		default_sample_duration_present = 0x000008
		default_sample_size_present = 0x000010
		default_sample_flags_present = 0x000020
		duration_is_empty = 0x010000
		default_base_is_moof = 0x020000

	def __init__(self,
		flags: Flags,
		track_ID: int,
		base_data_offset: Optional[int]=None,
		sample_description_index: Optional[int]=None,
		default_sample_duration: Optional[int]=None,
		default_sample_size: Optional[int]=None,
		default_sample_flags: Optional[int]=None,
	) -> None:
		self.flags = flags # TODO: set flags based on presence of optional fields
		self.track_ID = track_ID
		self.base_data_offset = base_data_offset
		self.sample_description_index = sample_description_index
		self.default_sample_duration = default_sample_duration
		self.default_sample_size = default_sample_size
		self.default_sample_flags = default_sample_flags
		
	
	@classmethod
	def _from_body(cls, body: GoodBytesIO, ctx: dict) -> Self:
		version, flags = cls._read_fullbox(body)
		assert(version == 0)
		flags = cls.Flags(flags)
		track_ID = body.readBEU32()
		base_data_offset = body.readBEU64() if flags & cls.Flags.base_data_offset_present else None
		sample_description_index = body.readBEU32() if flags & cls.Flags.sample_description_index_present else None
		default_sample_duration = body.readBEU32() if flags & cls.Flags.default_sample_duration_present else None
		default_sample_size = body.readBEU32() if flags & cls.Flags.default_sample_size_present else None
		default_sample_flags = body.readBEU32() if flags & cls.Flags.default_sample_flags_present else None
		
		return cls(
			flags=flags,
			track_ID=track_ID,
			base_data_offset=base_data_offset,
			sample_description_index=sample_description_index,
			default_sample_duration=default_sample_duration,
			default_sample_size=default_sample_size,
			default_sample_flags=default_sample_flags
		)
	
	def _into_body(self, body: GoodBytesIO, ctx: dict) -> None:
		self._write_fullbox(body, version=0, flags=self.flags)
		body.writeBEU32(self.track_ID)
		if self.flags & self.Flags.base_data_offset_present:
			body.writeBEU64(self.base_data_offset)
		if self.flags & self.Flags.sample_description_index_present:
			body.writeBEU32(self.sample_description_index)
		if self.flags & self.Flags.default_sample_duration_present:
			body.writeBEU32(self.default_sample_duration)
		if self.flags & self.Flags.default_sample_size_present:
			body.writeBEU32(self.default_sample_size)
		if self.flags & self.Flags.default_sample_flags_present:
			body.writeBEU32(self.default_sample_flags)


@Box.register
class Saiz(Box):
	"""
	8.7.8 Sample Auxiliary Information Sizes Box
	"""
	boxtype = b"saiz"

	def __init__(self,
		default_sample_info_size=int,
		sample_count=int,
		aux_info_type: Optional[int]=None,
		aux_info_type_parameter: Optional[int]=None,
		sample_info_size: Optional[List[int]]=None
	) -> None:
		self.default_sample_info_size = default_sample_info_size
		self.sample_count = sample_count
		self.aux_info_type = aux_info_type
		self.aux_info_type_parameter = aux_info_type_parameter
		self.sample_info_size = sample_info_size

	@classmethod
	def _from_body(cls, body: GoodBytesIO, ctx: dict) -> Self:
		version, flags = cls._read_fullbox(body)
		assert(version == 0)
		if flags & 1:
			aux_info_type = body.readBEU32()
			aux_info_type_parameter = body.readBEU32()
		else:
			aux_info_type = None
			aux_info_type_parameter = None
		default_sample_info_size = body.readBEU08()
		sample_count = body.readBEU32()
		if default_sample_info_size == 0:
			sample_info_size = [body.readBEU08() for _ in range(sample_count)]
		else:
			sample_info_size = None
		
		return cls(
			default_sample_info_size=default_sample_info_size,
			sample_count=sample_count,
			aux_info_type=aux_info_type,
			aux_info_type_parameter=aux_info_type_parameter,
			sample_info_size=sample_info_size,
		)
	
	def _into_body(self, body: GoodBytesIO, ctx: dict) -> None:
		flags = (self.aux_info_type is not None) * 0x01
		self._write_fullbox(body, version=0, flags=flags)
		if flags & 1:
			body.writeBEU32(self.aux_info_type)
			body.writeBEU32(self.aux_info_type_parameter)
		body.writeBEU08(self.default_sample_info_size)
		body.writeBEU32(self.sample_count)
		if self.default_sample_info_size == 0:
			for size in self.sample_info_size:
				body.writeBEU08(size & 0xff) # XXX: overflows produce technically invalid MP4s, but many players don't check this



@Box.register
class Saio(Box):
	"""
	8.7.9 Sample Auxiliary Information Offsets Box
	"""
	boxtype = b"saio"

	def __init__(self,
		offset=List[int],
		aux_info_type: Optional[int]=None,
		aux_info_type_parameter: Optional[int]=None,
	) -> None:
		self.offset = offset
		self.aux_info_type = aux_info_type
		self.aux_info_type_parameter = aux_info_type_parameter

	@classmethod
	def _from_body(cls, body: GoodBytesIO, ctx: dict) -> Self:
		version, flags = cls._read_fullbox(body)
		if flags & 1:
			aux_info_type = body.readBEU32()
			aux_info_type_parameter = body.readBEU32()
		else:
			aux_info_type = None
			aux_info_type_parameter = None
		entry_count = body.readBEU32()

		if version == 0:
			offset = [body.readBEU32() for _ in range(entry_count)]
		elif version == 1:
			offset = [body.readBEU64() for _ in range(entry_count)]
		else:
			raise ValueError("unknown version")
		
		#print(body.tell() - ctx["top_offset"] + 16, offset)
		#exit()

		return cls(
			offset,
			aux_info_type,
			aux_info_type_parameter
		)
	
	def _into_body(self, body: GoodBytesIO, ctx: dict) -> None:
		version = 0 if all(x < 2**32 for x in self.offset) else 1
		flags = (self.aux_info_type is not None) * 0x01
		self._write_fullbox(body, version, flags)
		if flags & 1:
			body.writeBEU32(self.aux_info_type)
			body.writeBEU32(self.aux_info_type_parameter)
		body.writeBEU32(len(self.offset))
		for off in self.offset:
			if version == 0:
				body.writeBEU32(off)
			else:
				body.writeBEU64(off)


@Box.register
class Trun(Box):
	"""
	8.8.8 Track Fragment Run Box
	"""
	boxtype = b"trun"

	class Flags(IntFlag):
		data_offset_present = 0x000001
		first_sample_flags_present = 0x000004
		sample_duration_present = 0x000100
		sample_size_present = 0x000200
		sample_flags_present = 0x000400
		sample_composition_time_offsets_present = 0x000800

	def __init__(self,
		flags: Flags,
		sample_count: int,
		data_offset: Optional[int]=None,
		truns: List[dict]=[],
	) -> None:
		self.flags = flags
		self.sample_count = sample_count
		self.data_offset = data_offset
		self.truns = truns

	@classmethod
	def _from_body(cls, body: GoodBytesIO, ctx: dict) -> Self:
		version, flags = cls._read_fullbox(body)
		flags = cls.Flags(flags)
		sample_count = body.readBEU32()
		data_offset = body.readBES32() if flags & cls.Flags.data_offset_present else None
		first_sample_flags = body.readBEU32() if flags & cls.Flags.first_sample_flags_present else None
		truns = []
		for i in range(sample_count):
			run = {}
			run["sample_duration"] = body.readBEU32() if flags & cls.Flags.sample_duration_present else None
			run["sample_size"] = body.readBEU32() if flags & cls.Flags.sample_size_present else None

			if i==0 and first_sample_flags is not None:
				run["sample_flags"] = first_sample_flags
			else:
				run["sample_flags"] = body.readBEU32() if flags & cls.Flags.sample_flags_present else None
			
			if version == 0:
				run["sample_composition_time_offset"] = body.readBEU32() if flags & cls.Flags.sample_composition_time_offsets_present else None
			elif version == 1:
				run["sample_composition_time_offset"] = body.readBES32() if flags & cls.Flags.sample_composition_time_offsets_present else None
			else:
				raise ValueError("unknown version")

			truns.append(run)

		return cls(
			flags=flags,
			sample_count=sample_count,
			data_offset=data_offset,
			truns=truns
		)


	def _into_body(self, body: GoodBytesIO, ctx: dict) -> None:
		# always using v1 seems to result in a clean round-trip
		version = 1# if any(run["sample_composition_time_offset"] < 0 for run in self.truns) else 0
		self._write_fullbox(body, version=version, flags=self.flags)
		body.writeBEU32(self.sample_count)
		if self.flags & self.Flags.data_offset_present:
			body.writeBES32(self.data_offset)
		if self.flags & self.Flags.first_sample_flags_present:
			body.writeBEU32(self.truns[0]["sample_flags"])
		for i, run in enumerate(self.truns):
			if self.flags & self.Flags.sample_duration_present:
				body.writeBEU32(run["sample_duration"])
			if self.flags & self.Flags.sample_size_present:
				body.writeBEU32(run["sample_size"])
			
			if i==0 and self.flags & self.Flags.first_sample_flags_present:
				pass
			elif self.flags & self.Flags.sample_flags_present:
				body.writeBEU32(run["sample_flags"])
			
			if self.flags & self.Flags.sample_composition_time_offsets_present:
				if version == 0:
					body.writeBEU32(run["sample_composition_time_offset"])
				else:
					body.writeBES32(run["sample_composition_time_offset"])

@Box.register
class Tfdt(Box):
	"""
	8.8.12 Track fragment decode time
	"""
	boxtype = b"tfdt"

	def __init__(self, base_media_decode_time: int) -> None:
		self.base_media_decode_time = base_media_decode_time

	@classmethod
	def _from_body(cls, body: GoodBytesIO, ctx: dict) -> Self:
		version, flags = cls._read_fullbox(body)
		assert(flags == 0)
		if version == 0:
			base_media_decode_time = body.readBEU32()
		elif version == 1:
			base_media_decode_time = body.readBEU64()
		else:
			raise ValueError(f"Unrecognised version: {version}")
		return cls(base_media_decode_time)
	
	def _into_body(self, body: GoodBytesIO, ctx: dict) -> None:
		self._write_fullbox(body, version=1, flags=0)
		body.writeBEU64(self.base_media_decode_time) # TODO: use v0 if possible


@Box.register
class Sinf(ContainerBox):
	"""
	8.12.1 Protection Scheme Information Box
	"""
	boxtype = b"sinf"


@Box.register
class Schm(Box):
	"""
	8.12.5 Scheme Type Box
	"""
	boxtype = b"schm"

	def __init__(self,
		scheme_type: bytes,
		scheme_version: Tuple[int, int],
		scheme_uri: Optional[str]=None
	) -> None:
		self.scheme_type = scheme_type
		self.scheme_version = scheme_version
		self.scheme_uri = scheme_uri

	@classmethod
	def _from_body(cls, body: GoodBytesIO, ctx: dict) -> Self:
		version, flags = cls._read_fullbox(body)
		assert(version == 0)
		scheme_type = body.read_exact(4)
		scheme_version = body.readFP1616()
		scheme_uri = body.read().decode() if flags & 1 else None
		return cls(
			scheme_type=scheme_type,
			scheme_version=scheme_version,
			scheme_uri=scheme_uri
		)
	
	def _into_body(self, body: GoodBytesIO, ctx: dict) -> None:
		self._write_fullbox(body, version=0, flags=(self.scheme_uri is not None) * 0x01)
		body.write(self.scheme_type)
		body.writeFP1616(self.scheme_version)
		if self.scheme_uri is not None:
			body.write(self.scheme_uri.encode())


@Box.register
class Schi(ContainerBox):
	"""
	8.12.6 Scheme Information Box
	"""
	boxtype = b"schi"



"""
CENC-specific boxes
"""


@Box.register
class Senc(Box):
	"""
	7.2.1 Sample Encryption Box
	"""
	boxtype = b"senc"

	class Flags(IntFlag):
		use_subsample_encryption = 0x02

	def __init__(self, flags: Flags, sample_info: List[dict]) -> None:
		self.flags = flags
		self.sample_info = sample_info

	@classmethod
	def _from_body(cls, body: GoodBytesIO, ctx: dict) -> Self:
		#print("default_Per_Sample_IV_Size", ctx["tenc"].default_Per_Sample_IV_Size)
		if "tenc" in ctx:
			iv_size = ctx["tenc"].default_Per_Sample_IV_Size
		else:
			iv_size = 16 # TODO: raise exception, we should fix this...
		version, flags = cls._read_fullbox(body)
		assert(version == 0)
		flags = cls.Flags(flags)
		sample_info = []
		sample_count = body.readBEU32()
		for _ in range(sample_count):
			sample = {
				"iv": body.read_exact(iv_size)
			}
			if flags & cls.Flags.use_subsample_encryption:
				sample["subsamples"] = []
				subsample_count = body.readBEU16()
				for _ in range(subsample_count):
					sample["subsamples"].append({
						"clearbytes": body.readBEU16(),
						"encbytes": body.readBEU32()
					})
			sample_info.append(sample)
		return cls(
			flags=flags,
			sample_info=sample_info
		)
	
	def _into_body(self, body: GoodBytesIO, ctx: dict) -> None:
		self._write_fullbox(body, version=0, flags=self.flags)
		body.writeBEU32(len(self.sample_info))
		for sample in self.sample_info:
			body.write(sample["iv"])
			if self.flags & self.Flags.use_subsample_encryption:
				subsamples = sample["subsamples"]
				body.writeBEU16(len(subsamples))
				for subsample in subsamples:
					body.writeBEU16(subsample["clearbytes"])
					body.writeBEU32(subsample["encbytes"])


@Box.register
class Pssh(Box):
	"""
	8.1 Protection system specific header box
	"""
	boxtype = b"pssh"

	def __init__(self, system_id: bytes, data: bytes, KIDs: Optional[List[bytes]]=None) -> None:
		self.system_id = system_id
		self.data = data
		self.KIDs = KIDs

	@classmethod
	def _from_body(cls, body: GoodBytesIO, ctx: dict) -> Self:
		version, flags = cls._read_fullbox(body)
		assert(flags == 0)
		system_id = body.read_exact(16)
		if version == 0:
			KIDs = None
		elif version == 1:
			kid_count = body.readBEU32()
			KIDs = [body.read_exact(16) for _ in range(kid_count)]
		else:
			raise ValueError(f"Unrecognised version: {version}")
		data = body.read_exact(body.readBEU32())
		return cls(
			system_id=system_id,
			data=data,
			KIDs=KIDs
		)
	
	def _into_body(self, body: GoodBytesIO, ctx: dict) -> None:
		version = 0 if self.KIDs is None else 1
		self._write_fullbox(body, version=version, flags=0)
		body.write(self.system_id)
		if version == 1:
			body.writeBEU32(len(self.KIDs))
			for kid in self.KIDs:
				assert(len(kid) == 16)
				body.write(kid)
		body.writeBEU32(len(self.data))
		body.write(self.data)


@Box.register
class Tenc(Box):
	"""
	8.2 Track Encryption box
	"""
	boxtype = b"tenc"

	def __init__(self,
		default_isProtected: int,
		default_Per_Sample_IV_Size: int,
		default_KID: bytes,
		default_constant_IV: Optional[bytes]=None,
		default_crypt_byte_block: Optional[int]=None,
		default_skip_byte_block: Optional[int]=None
	) -> None:
		self.default_isProtected = default_isProtected
		self.default_Per_Sample_IV_Size = default_Per_Sample_IV_Size
		self.default_KID = default_KID
		self.default_constant_IV = default_constant_IV
		self.default_crypt_byte_block = default_crypt_byte_block
		self.default_skip_byte_block = default_skip_byte_block

	@classmethod
	def _from_body(cls, body: GoodBytesIO, ctx: dict) -> Self:
		version, flags = cls._read_fullbox(body)
		assert(flags == 0)
		assert(body.readBEU08() == 0) # reserved
		if version == 0:
			assert(body.readBEU08() == 0) # reserved
			default_crypt_byte_block = None
			default_skip_byte_block = None
		else:
			val = body.readBEU08() # TODO: are these the right way around?
			default_crypt_byte_block = val & 0xf
			default_skip_byte_block = val >> 4
		default_isProtected = body.readBEU08()
		default_Per_Sample_IV_Size = body.readBEU08()
		default_KID = body.read_exact(16)
		if default_isProtected == 1 and default_Per_Sample_IV_Size == 0:
			default_constant_IV_size = body.readBEU08()
			default_constant_IV = body.read_exact(default_constant_IV_size)
		else:
			default_constant_IV = None

		res = cls(
			default_isProtected=default_isProtected,
			default_Per_Sample_IV_Size=default_Per_Sample_IV_Size,
			default_KID=default_KID,
			default_constant_IV=default_constant_IV,
			default_crypt_byte_block=default_crypt_byte_block,
			default_skip_byte_block=default_skip_byte_block,
		)
		ctx["tenc"] = res
		return res
	
	def _into_body(self, body: GoodBytesIO, ctx: dict) -> None:
		version = 0 if self.default_crypt_byte_block is None else 1
		self._write_fullbox(body, version=version, flags=0)
		body.writeBEU08(0) # reserved
		if version == 0:
			body.writeBEU08(0) # reserved
		else:
			body.writeBEU08((self.default_skip_byte_block << 4) | self.default_crypt_byte_block)
		body.writeBEU08(self.default_isProtected)
		body.writeBEU08(self.default_Per_Sample_IV_Size)
		body.write(self.default_KID)
		if self.default_isProtected == 1 and self.default_Per_Sample_IV_Size == 0:
			body.writeBEU08(len(self.default_constant_IV))
			body.write(self.default_constant_IV)

if __name__ == "__main__":
	opaque = OpaqueBox(b"abcd", b"opaque")
	print(opaque)

	tfdt = Tfdt(1234)
	print(tfdt)
	
	buf = io.BytesIO()
	tfdt.write_into(buf, {})
	serialized = buf.getvalue()
	print(serialized)

	parsed = Box.parse(io.BytesIO(serialized), {})
	print(parsed)

	parsed = Tfdt.parse(io.BytesIO(serialized), {})
	print(parsed) # exactly the same result

	parsed = OpaqueBox.parse(io.BytesIO(serialized), {})
	print(parsed) # this should remain opaque

	try:
		# This will raise a type error
		parsed = Traf.parse(io.BytesIO(serialized), {})
		assert(False)
	except TypeError as e:
		print(e)

	traf = Traf([tfdt]*4 + [Traf([tfdt])])
	print(traf)
	print(Traf([]))
	print(Traf([tfdt]))
