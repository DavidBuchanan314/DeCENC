from lib.util import xor_bytes

# this is the result of FFMPEG trying to convert limited range to full range
FFMPEG_LUT = b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x02\x03\x05\x06\x07\x08\t\n\x0c\r\x0e\x0f\x10\x11\x13\x14\x15\x16\x17\x18\x1a\x1b\x1c\x1d\x1e\x1f!"#$%&()*+,-/012346789:;=>?@ABDEFGHIKLMNOPRSTUVWXZ[\\]^_abcdefhijklmopqrstvwxyz{}~\x7f\x80\x81\x82\x84\x85\x86\x87\x88\x89\x8b\x8c\x8d\x8e\x8f\x90\x92\x93\x94\x95\x96\x97\x99\x9a\x9b\x9c\x9d\x9e\xa0\xa1\xa2\xa3\xa4\xa5\xa7\xa8\xa9\xaa\xab\xac\xad\xaf\xb0\xb1\xb2\xb3\xb4\xb6\xb7\xb8\xb9\xba\xbb\xbd\xbe\xbf\xc0\xc1\xc2\xc4\xc5\xc6\xc7\xc8\xc9\xcb\xcc\xcd\xce\xcf\xd0\xd2\xd3\xd4\xd5\xd6\xd7\xd9\xda\xdb\xdc\xdd\xde\xe0\xe1\xe2\xe3\xe4\xe5\xe7\xe8\xe9\xea\xeb\xec\xee\xef\xf0\xf1\xf2\xf3\xf5\xf6\xf7\xf8\xf9\xfa\xfc\xfd\xfe\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff'
OTHER_LUT  = b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x02\x03\x05\x06\x07\x08\t\n\x0c\r\x0e\x0f\x10\x11\x13\x14\x15\x16\x17\x18\x1a\x1b\x1c\x1d\x1e\x1f!"#$%&()*+,-/012346789:;=>?@ABDEFGHIKLMNOPRSTUVWXZ[\\]^_abcdefhijklmopqrstvwxyz{}~\x7f\x80\x81\x82\x84\x85\x86\x87\x88\x89\x8b\x8c\x8d\x8e\x8f\x90\x92\x93\x94\x95\x96\x97\x99\x9a\x9b\x9c\x9d\x9e\xa0\xa1\xa2\xa3\xa4\xa5\xa7\xa8\xa9\xaa\xab\xac\xad\xaf\xb0\xb1\xb2\xb3\xb4\xb6\xb7\xb8\xb9\xba\xbb\xbd\xbe\xbf\xc0\xc1\xc2\xc4\xc5\xc6\xc7\xc8\xc9\xcb\xcc\xcd\xce\xcf\xd0\xd2\xd3\xd4\xd5\xd6\xd7\xd9\xda\xdb\xdc\xdd\xde\xe0\xe1\xe2\xe3\xe4\xe5\xe7\xe8\xe9\xea\xeb\xec\xee\xef\xf0\xf1\xf2\xf3\xf5\xf6\xf7\xf8\xf9\xfa\xfc\xfd\xfe\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff'

def pc_to_tv(x: int) -> int:
	# map 0-255 onto 16-235
	return 16+(x*219)//255

def tv_to_pc(x: int) -> int:
	return FFMPEG_LUT[x]
	# map 16-235 onto 0-255
	tmp = ((x-16)*255)//219
	if tmp <= 0:
		return 0
	if tmp >= 255:
		return 255
	return tmp

tuples = []
for i in range(0x100):
	tuples.append((tv_to_pc(i), tv_to_pc(i^0x80)))

trans_full = [0]*256
trans_a = [0]*256
trans_b = [0]*256
for i in range(0x100):
	trans_full[tv_to_pc(i)] = i
	if ((i+0x40)&0x80):
		trans_a[tv_to_pc(i)] = i
	else:
		trans_b[tv_to_pc(i^0x80)] = i

trans_full = bytes(trans_full)
trans_a = bytes(trans_a)
trans_b = bytes(trans_b)


def recover_fullrange(buf_a: bytes, buf_not_a: bytes) -> bytes:
	return xor_bytes(buf_a.translate(trans_a), buf_not_a.translate(trans_b))

def recover_partial(buf: bytes) -> bytes:
	return buf.translate(trans_full)


class RangeFixer:
	def __init__(self, ramp: bytes) -> None:
		assert(len(ramp) == 0x100)
		self.ramp = ramp
		trans_full = [0]*256
		trans_a = [0]*256
		trans_b = [0]*256
		for i in range(0x100):
			trans_full[ramp[i]] = i
			if ((i+0x40)&0x80):
				trans_a[ramp[i]] = i
			else:
				trans_b[ramp[i^0x80]] = i
		trans_full[0] = 0 # preserve 0->0 mapping (this makes parsing MAGIC_PATTERN for checksumming easier)
		self._trans_full = bytes(trans_full)
		self._trans_a = bytes(trans_a)
		self._trans_b = bytes(trans_b)
	
	def recover_fullrange(self, buf_a: bytes, buf_not_a: bytes) -> bytes:
		return xor_bytes(buf_a.translate(self._trans_a), buf_not_a.translate(self._trans_b))

	def recover_partial(self, buf: bytes) -> bytes:
		return buf.translate(self._trans_full)

trans_full = bytes(trans_full)
trans_a = bytes(trans_a)
trans_b = bytes(trans_b)


if __name__ == "__main__":
	sample_a = bytes([tv_to_pc(i) for i in range(0x100)])
	sample_b = bytes([tv_to_pc(i^0x80) for i in range(0x100)])

	reference = bytes(range(0x100))
	result = recover_fullrange(sample_a, sample_b)
	assert(reference == result)

	#print(recover_limited(sample_a))
	a = bytes(tv_to_pc(i) for i in range(0x100))
	b = FFMPEG_LUT
	print(a.hex())
	print(FFMPEG_LUT.hex())
	print(a == b)

	foo = b'P5\n27 27\n255\n%\x19\x18\x18\x18\x0e+++++++++++++++++++++A\x1d\x18\x18\x18\x0e+++++++++++++++++++++D2\x19\x19\x18\x0e+++++++++++++++++++++GD\x1e\x19\x18\x0e+++++++++++++++++++++CC-\x1d\x1c\x0e+++++++++++++++++++++CC7\x19\x18\x0e+++++++++++++++++++++CD>\x18\x17\x0e\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0cBDB\x18\x17\x0e=c;>H;\x13\x13%_c0,*a)\x00ot\xb2\x9dBBA\x16\x17\x0e?\xff\xec\xf2G\x18\x9f\x8f\xd4\xff\xd4S\x9c\x88V\x85\x11\xd6\x1b\x00\xb2BCC\x18\x19\x0e%%%%%%%%%%%&+-(%\x8d\x82\xd0\xd46BCC\x18\x18\x0e)--_/+__^,(,d%a_\x93\x9bV:\xf3CCB\x17\x17\x0e%%%%%%%%%%%%%%_-2\xac\xff\xb8\x10BCD\x18\x18\x0eacmaacmaacmaacma\xff\x8a]\x00\xc8BCC\x17\x16\x0e]^_abcdefhijklmo\xff^\x9b1\xf3CCC\x18\x18\x0epqrstvwxyz{}~\x7f\x80\x81&*\xc0\xf9=CCB\x18\x18\x0e\x82\x83\x85\x86\x87\x88\x89\x8a\x8c\x8d\x8e\x8f\x90\x91\x93\x949B\xc8\x00%CCB\x18\x18\x0e\x95\x96\x97\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa1\xa2\xa3\xa4\xa5\xa6W\x1f\xda_-CDC\x17\x18\x0e\xa8\xa9\xaa\xab\xac\xad\xaf\xb0\xb1\xb2\xb3\xb4\xb6\xb7\xb8\xb9\xff\xff\x00\x00\x01CDE\x19\x17\x0e\xba\xbb\xbd\xbe\xbf\xc0\xc1\xc2\xc4\xc5\xc6\xc7\xc8\xc9\xcb\xcc\t\x85-\t?BDE\x1a\x18\x0e\xcd\xce\xcf\xd0\xd2\xd3\xd4\xd5\xd6\xd7\xd9\xda\xdb\xdc\xdd\xde\x17@\xff\xed\xd7CDD\x18\x18\x0e\xdf\xe1\xe2\xe3\xe4\xe5\xe6\xe8\xe9\xea\xeb\xec\xed\xef\xf0\xf1V\xff\xa2\x18\xffCCC\x17\x17\x0e\xf2\xf3\xf4\xf6\xf7\xf8\xf9\xfa\xfb\xfd\xfe\xff\xff\xff\xff\xff\xf2>j\x16\xfaACC\x19\x18\x0e\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xed}^\xa3\x05ACC\x19\x19\x0e\x0f>x\xff\xc6\xa1\xd0p\x85(tS\xde\xe8\x9f\x87k\xd3\x8a\xc4vABB\x17\x19\x0e\xb9\xdf\x8eKEv\\\xfe\x9a*\xf8s\xcf\x9f\xdc\x9a\xb1\xc4\x00~h@AA\x16\x17\x0e[Q\xf3\xc24\xc2}m\x80\xb3\xff\xe3\x16j\x88\xc2\x11\xff\xb9\xc4mAAA\x15\x14\x0e\x96\xfd\xff\xd9oX\x00x\xff!c\xff\x01\xa1\xff\xff\x8aw%h\xd7'
	print(recover_partial(foo))
